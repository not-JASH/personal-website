<!doctype html>
<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Wave GAN</title>
		
		<link href="/css/main_stylesheet.css" rel="stylesheet" type="text/css">
		<script type="text/javascript" async
  			src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
		</script>
		
		<style>
			body {
				width: 100%;
				max-width:none;
				padding:0px 0px 0px 0px;
			}
			
			a {
				display: block;
				font-size: 14px;
			}
			
			a:active {
				font-weight:normal;
			}
			
			/*table,th,td {
				border: 1px solid black;
				border-collapse: collapse;
			}*/
			
			td, th, ol {
				font-size: 14px;
			}
			
			li {
				font-size: 14px;
				margin-bottom:4px;
			}
			
			.at {
				vertical-align: top;
			}
			
			.pb10 {
				padding-bottom: 12px;
			}
			
			.CHARS {
				padding:25px 0px 0px 0px;
			}

			
			.grid-container {
				grid-template-columns: repeat(5,auto);
			}
			
			.index {
				position:fixed;
				width:200px;
				top:90px;
				left:50%;
				margin-left:-550px;
			}
			
			.main-text {
				align-content: center;
				margin:auto;
				width: 550px;
			}			
			
			.index a{
				font-size:16px;
			}

			.index a:hover {
				color:white;
				background-color: black;
			}

			.index nav {
				padding:0px 0px 0px 0px;
			}
			
			img {
				max-width: 100%;
				margin-left:auto;
				margin-right:auto;
				display: block;
				padding-bottom:0px;
			}
						
			.fig {
				font-size: 12px;
				text-align: center;
				padding: 0px 0px 0px 0px;
			}
			
			.alg {}
			
			.eqn {}
			
		</style>
	</head>
	
	<body>		
		<div class="index">
			<nav>
				<a href="/">Home</a>
				<a href="/Portfolio">Portfolio</a>
			</nav>
			<hr>
			<nav>
				<a href="#Finite-States">Finite States</a>
				<a href="#Entropy">Entropy</a>
				<a href="#Random-Walks">Random Walks</a>
				<a href="#Networks">Networks</a>
				<a href="#Results">Results</a>
				<a href="#Conjecture">Conjecture</a>
				<a href="#appendix">Appendix</a>
				<a download
					href="https://onedrive.live.com/embed?cid=8912A15B8F0CAFF4&resid=8912A15B8F0CAFF4%212403&authkey=AH751rUvsmbCKto&em=2">
					Full Report</a>
			</nav>

		</div>
		
		<div class="main-text">		
			<h1>WaveGAN</h1>
			<h2>Wavelet Augmented Vector Extrapolation with Generative Adversarial Networks</h2>
			
			<img src="https://chi01pap001files.storage.live.com/y4mo_jBywMukJQ5K8aHumXJescXPQQKitJubr1kJCrJRtocJhkB1XZYwYc45I8dKD9rKBhNgOu0BwUGRavm98jqeNM1BEfPkHMYGvWYv3oILidAAQFQNVQDQ5jqpqqVJc-LCK5BR9TRNQrdyUKYsb-TehiwwVakjBil07exMo3CJ0TZi0Cc5CAy6tlhPIegAD2i?width=1432&height=777&cropmode=none">
			<h5 class="fig">Top-view, real values of sample at wavelet level 7.</h5>
			
			<div id="Finite-States">			
				<h3>Finite States</h3>
				<p>
					A butterfly flaps its wings today, tomorrow there is a tornado. It is therefore wise for meteorologists to observe butterflies. But what if there are lots of butterflies? What if there are lots of butterflies in a tornado, during an earthquake? What if the only measuring device is a seismometer? Could a meteorologist with only this seismometer’s readings, reliably predict next month’s weather? With wavelets and neural networks, yes. 
				</p>
				
				<p>
					In a closed system, information about future states is contained in past and present state-information. This means that for any finite state model there exists a function that can, with information of the past and present, accurately predict future states. Some systems are more easily modeled than others; in general, the accuracy with which a system’s future states can be predicted is inversely proportional to the system’s entropy.  The price of bitcoin is highly volatile. It frequently experiences vast changes and is considered generally hard to model. BTCUSDT is therefore an excellent example for this investigation. With wavelets and neural networks, a transfer function will be obtained that can with information on past and present states, accurately predict system-states. Before passing through a neural network, BTCUSDT data’s entropy is increased by a complex wavelet transform of a sample and by maintaining a windowed record of the sample’s transform through time.
				</p>
			</div>
			
			<div id="Entropy">				
				<h3>Entropy</h3>
				<p>
					Shannon entropy H quantifies entropy as a function of how likely system states are to occur. For a discrete variable \(x\) with known entropy \(P(x)\). For continuous variables with unknown probabilities, entropy can be heuristically determined with histograms. The probability of a function state is approximated by the probability that the random function has a value within a specified range. For intervals of equal width \(w_s\) between \(l_k\) and \(u_k\). One thousand samples of BTCUSDT containing 256 minutes of candle intervals had average entropy 910.45. 
				</p>
				
				<div class="eqn">
					$$ H(x) = -\sum_{i=1}^{n}p(x_i{})\cdot log(P(x_i{})) $$
					$$ P_k = \int_{I_k}^{U_k}f(x)dx $$
					$$ H(x) = -\sum_{k=1}^{n}P_k\cdot log(P_k)+log(W) $$
				</div>
				
				<img src="https://chi01pap001files.storage.live.com/y4m6DT9fuEzIS6ZNIY5P6Fl_tB-LVI1q-fLWgguglaITTygoF_nf0ZCikgvySNb3P0gJUCCw0f9VUCmZPzX2U_AdUmxGJ7NXNw81MBcxiOV1JygEQjQoXTsiCBT_G7J5tCIHJ6ajkRinXkIhO6UoBMGwBT3k-fNrC_6dY0prq9a-uhkGpdqGsqDeJX3vydQij-K?width=560&height=411&cropmode=none">
				<h5 class="fig">Top-view, real values of sample at wavelet level 5. [minutes]</h5>		
			</div>
			
			<div id="Random-Walks">			
				<h3>Random Walks</h3>
				<p>
					The price of Bitcoin at time \(t\) is \(V(t)\left \{ t, \mathcal{B}(t) \in \mathbb{R} : t,\mathcal{B}(t) &gt 0\right \}\). In this experiment, a function to determine the price of bitcoin at time \(t + Δt\) from the price at time t was determined. The function is described as \( \mathcal{B}(t)_{t_2,t_3} = f(\Theta,\mathcal{B}(t)_{t_1,t_2}\left \{ t \in \mathbb{R} : t \geq 0 \right \}\)
					for some parameters \(Θ\). This function and its parameters were determined analytically by minimizing loss on a hierarchical neural network. 
				</p>
				
				<div class="eqn">
					$$ \Theta = argmin \mathcal{L}\left [ \mathcal{B}(t)_{t_1,t_2},f(\Theta,\mathcal{B}(t)_{t_3,t_4})))  \right ] $$
				</div>
				
				<p>
					Since the price of bitcoin has random-walk properties, samples taken from V(t) are likely to have different means and variances. Conversely, if samples are taken from ,V'(t) , mean will approximately be zero and samples will have similar variances. For a sample X with n elements:
				</p>
				
				<div class="eqn">
					$$ \lim_{n \rightarrow \infty} \mathbb{E}[\mathcal{B}'(x)] = 0 $$
					$$ \mathcal{B}(t_2) = \mathcal{B}(t_1) + \int_{t_1}^{t_2}\mathcal{B}'(t)dt $$
					$$ \mathcal{B}(t)_{t_2,t_3} = f(\Theta , \mathcal{B}(t)_{t_2},\mathcal{B}'(t)_{t_1,t_2}) $$
					$$ \mathcal{B}'(t)_{t_2,t_3} = f(\Theta,\mathcal{B}'(t)_{t_1,t_2}) $$
					$$ \Theta = argmin \mathcal{L}[\mathcal{B}'(t)_{t_2,t_3},f(\Theta,\mathcal{B}'(t)_{t_1,t_2})] $$
				</div>
				
				<p>
					Data samples’ dimensionality was increased, by windowing the complex wavelet transform of samples with n elements, between time zero and time n. This creates multiple redundant sources of information for the network model to analyze. 
				</p>
				
				<img src="https://chi01pap001files.storage.live.com/y4mcvoF3JxVdVr90UedTHX0Z3Dfd3aEencbdZpFSl_exzJJ_VXqp5wT57GX3JMWPpntCnr6wzxSr5r1g5_SCzzDXHFeGxNLSkvAw5An0ncwhGlgP3DrN1_Ayt8TlVkSDs_eooggxZsm6ox9Bcmh6eVq7nWZZ3pcdhMiPokYUG52x11BQFU3XaP8QeYHr7jolxX-?width=1430&height=776&cropmode=none">
				<h5 class="fig">2/3 view, real values of sample at wavelet level 7.</h5>
				
				<div class="alg">
					<hr>
					<h4>Algorithm: Increasing Sample Dimensionality</h4>
					<div class="grid-container" style="grid-template-columns: 225px auto;">
						<div class="grid-item" style="text-align: left;font-size: 14px;">
							Iterate while \(t &lt t_o + w_s \):
							<ol style="padding-left:1.2em;">
								<li>\( S_x \leftarrow \mathcal{D}(t,t+w_s) \)</li>	
								<li>\(S_y \leftarrow \mathcal{D}(t + l_x,t+l_x +w_s)\)</li>	
								<li>\(X \leftarrow \begin{bmatrix} X\\ \mathbb{C}_{wt}(S_x) \end{bmatrix} \)</li>	
								<li>\(Y \leftarrow \begin{bmatrix} Y\\ \mathbb{C}_{wt}(S_y) \end{bmatrix} \)</li>	
								<li>\( t \leftarrow t + 1 \)</li>					
							</ol>
						</div>
						<div class="grid-item" style="text-align: left;">
							<table>
								<colgroup>
									<col style="width:80px;">
									<col style="width:">
								</colgroup>
								<tr>
									<td>\(\mathcal{D} \)</td>
									<td>BTCUSD sampled once per minute.</td>
								</tr>
								<tr>
									<td>\(S_x,S_y \)</td>
									<td>Vectorized samples of \(\mathcal{D}\) containing \(w_s\) elements, from \(t_o\) to \(t_n\).</td>
								</tr>
								<tr>
									<td>\(\mathbb{C}_{wt}(x) \)</td>
									<td>Complex Wavelet transform (Dualtree).</td>
								</tr>
								<tr>
									<td>\( t\)</td>
									<td>Sample time, initialized as \(t_o\).</td>
								</tr>
								<tr>
									<td>\(l_x\)</td>
									<td>Extrapolation length.</td>
								</tr>
								<tr>
									<td>\(X,Y\)</td>
									<td>Input and output sample arrays</td>
								</tr>
								<tr>
									<td>\(w_s \)</td>
									<td>Window size</td>
								</tr>
							</table>
						</div>		
					</div>		
					<hr>
				</div>
				
				<p>
					As can be seen in figures 1-3, structural patterns appear when the data is arranged in this manner. The resultant arrays X and Y are three dimensional. The size of the second and third dimensions of these arrays depends on the window size, choice of wavelet and level of deconstruction. Samples were interpolated such that dimensions were \([w_s,w_s,lvl]\), for lvl levels of wavelet decomposition. The way these samples were obtained means that some intersecting, perpendicular lines, of equal length represent the same information. For example, the information contained in \(X(w_s,∶,∶)\) is the interpolated wavelet transform of the sample between \(t_o+w_s\)and  \(t_o+2 \cdot w_s\) . \(X(:,w_s,:)\) is a history of the first value of the interpolated wavelet transform between \( t_o+w_s \) and \( t_o+2 \cdot w_s \). While \( X(w_s,∶,∶)  ≠X(:,w_s,:)\), the two encode the same information. This redundancy can be exploited by the network model. Furthermore, X and Y are complex valued. Selecting a complex-valued filter, orthonormal in Hilbert space, results in a decomposition where the complex portion roughly equals the real, with a 90-degree phase shift. Accordingly, the samples are separated into their real and complex parts and arranged real, complex, real… The final samples have dimensions  \([w_s,w_s,2 \cdot lvl]\). One thousand samples of X had an average entropy of 5.63e5.
				</p>
			</div>
			
			<div id="Networks">
				<h3>Networks</h3>
				<p>
					The network model and loss functions were pulled and adapted from Isola, Zhu, Zhou and Efros’ paper, Image-to-Image Translation with Conditional Adversarial Networks; also known as pixels to pixels. The proposed network is a “U-net” encoder decoder network with skipped connections and the loss functions are a combination of L1 and L2 loss, with the addition of a discriminator network. Because training samples had \(2 \cdot lvl\) channels, the pixels-to-pixels model was modified to use grouped convolutions.  The exact sizes of the convolution/transposed convolution layers tested were:
				</p>

				<div id="convolution-sizes">
					<hr>
					<div class="grid-container" style="grid-template-columns: auto auto;">
						<div class="grid-item" style="text-align: center;font-size: 14px;">
							<h4>Grouped Convolution Sizes</h4>
							<hr>
							<table style="width:210px;">
								<colgroup>
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
								</colgroup>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>2</td>
									<td>8</td>
									<td>7</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>14</td>
									<td>16</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>16</td>
									<td>32</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>32</td>
									<td>64</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>64</td>
									<td>128</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>256</td>
									<td>256</td>
									<td>2</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>512</td>
									<td>512</td>
									<td>1</td>
								</tr>
							</table>							
						</div>
						<div class="grid-item" style="text-align: center;font-size:14px;">
						<h4>Transposed Grouped Convolution Sizes</h4>
							<hr>
							<table style="width:210px;margin-left:50px;">
								<colgroup>
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
									<col style="width: 20%">
								</colgroup>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>512</td>
									<td>512</td>
									<td>1</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>256</td>
									<td>512</td>
									<td>2</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>128</td>
									<td>256</td>
									<td>2</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>64</td>
									<td>192</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>32</td>
									<td>96</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>16</td>
									<td>48</td>
									<td>4</td>
								</tr>
								<tr>
									<td>4</td>
									<td>4</td>
									<td>7</td>
									<td>60</td>
									<td>2</td>
								</tr>
							</table>	
						</div>		
					</div>		
					<hr>
				</div>
				
				<p>
					The dimensions specified have format \([F_x,F_y,C_g,F_g,N_g ]\) for filters of size \([f_x,f_y], C_g\) channels per group, \(F_g\) filters per group, and \(N_g\) groups. In between the grouped convolutions, there were hyperbolic tangent activations and batch-normalizations. The discriminator’s architecture was also pulled from pixels to pixels and is PatchGan. This discriminator model evaluates generator output in localized regions. This promotes details and prevents blurring. L1 and L2 losses were combined in the Generator’s loss function as recommended in pixels to pixels. 
				</p>
				<div class="eqn"></div>
					$$ \mathcal{L}_D = \lambda_1 \cdot \mathbb{E}[log(\Phi_D(Y,X))+log(1 - \Phi_D(\Phi_G(X),X))] $$
					$$ \mathcal{L}_G = \lambda_1 \cdot \mathbb{E}[log(\Phi_D(Y,X))] + \lambda_2 \cdot \mathbb{E}[\left | Y - \Phi_G(X)) \right |] $$
					$$ \left \{ \lambda_1,\lambda_2 \in \mathbb{R} : \lambda_1, \lambda_2 \neq 0 \right \} $$
					<p style="text-align: right;">(Chun)</p>
				<p>
					Because “U-net” is symmetrical, the outputs are the same size as inputs; to recover the extrapolated signal from this network, dimensionality must be reduced. The easiest way to do this would be to, by interpolation, resize and rearrange the data in \(X(w_s,:,:)\) so that it matches the dimensions of the specified complex wavelet transform for a sample sized \(w_s\) , then to take the inverse complex wavelet transform of that. This method, however, discards most of the extrapolated data and therefore does not make effective use of the information available. A second network could be trained to reduce the dimensionality of the first network’s output in a way that maximizes the accuracy of the inverse complex wavelet transform of the second network’s output. Ideally: 
				</p>
				<div class="eqn">
					$$ \widehat{X} = i\mathbb{C}wt(\Phi_2(\Phi_1(X))), \widehat{X}\approx S_y $$
				</div>
				<p>
					This network could be trained to minimize error between the expected signal and the inverse complex wavelet transform of its output. 
				</p>
				<div class="eqn">
					$$ \Theta = argmin \mathcal{L[S_y,X]} $$
					$$ \mathcal{L} = \mathbb{E}[\lambda \bigodot \left | S_y - i\mathbb{C}wt(\Phi_2(\Phi_1(X))) \right |] $$
				</div>
				<p>
					Since accuracy in extrapolated terms might be more important than elsewhere, bias can be introduced with vectorized coefficients λ . 
				</p>
			</div>	 
		
			
			<div id="Results">
				<img src="https://chi01pap001files.storage.live.com/y4mvSr7xr0Q42QQfT0m165Ranh2aHJ5cBIl1zr7n9GTo8DcC02BIR_MsYCgyfvOUns46PxYghOAUqERjJcUq75f3wgYUWfOt8r1Z7QMcTc7_QpJY50l9dCUoZhsxWh5hVfPHDlzheeYSVuWuL6sw37wBegmmWDc45vKmmbCFz6tRS4xQRUxvRsr2EOL4vBhFGDu?width=1429&height=706&cropmode=none">
				<h5 class="fig">Top-view(s), real values of sample, and extrapolation, at wavelet level 7</h5>
				
				
				<h3>Results</h3>
				<p>
					Several pixel-to-pixel networks (with grouped convolutions) were trained on varying sets of 1000 samples. They were trained with adaptive moment estimation using varying learning rates and batch size 32. With a window length of 256 minutes, three extrapolation lengths were considered: 30, 60 and 128 minutes. On average, trained networks had root mean squared error (rmse) of 0.21, 0.25 and 0.32 for extrapolation lengths 30, 60 and 128, respectively. Error was determined by the element wise subtraction of the network’s output from the corresponding reference output. For N samples, RMSE was calculated according to the equation listed above. The second network, whose inverse complex wavelet transformed output would approximately equal the reference signal, was not trained as it was sufficient for the purposes of this investigation to only evaluate the first’s performance. Results from training were not as expected, RMSE values were higher than anticipated and certainly larger than would be acceptable if reliable price-predictions were to be made. For more accurate results, a different network architecture could be implemented, or settings changed. Also, at this point it is unknown if the addition of the second network would improve prediction accuracy; furthermore, the complex wavelet transform’s scaling coefficients were discarded before training and the samples max-min scaled such that \({X,Y ∈ R∶ -1≤X,Y≤1}\). From the trained networks (as illustrated above), it can be concluded that to an extent, highly entropic systems, like the price of bitcoin can be accurately modeled by some unknown function, in this case, an analytically determined combination of wavelets and neural networks. If this were to be extended for practical use, scaling coefficients could be also predicted by extending the existing networks or adding another in parallel; it should be noted that the Dualtree wavelet transform’s scaling coefficients did not vary much for the time window used (256 min). These could probably be extrapolated accurately with a linear regression. 
				</p>
			</div>
			
			<div id="Conjecture">
				<h3>Conjecture</h3>
				<p>
					It was demonstrated that a transfer function that can predict future states from current and past states can be analytically determined. However, the dataset that was used in training has some unique properties which might make similar results difficult to obtain in other scenarios. The most important being that the price of bitcoin is measured independently of the data collection for this experiment. This means that it is negligibly changed, if at all, by the collection of these samples for network training; The price of bitcoin is unaffected by the training of this network. If the information produced by this trained network were used to make changes in the system it seeks to predict, the accuracy of its predictions would likely decrease quickly. This is because the system the function models is uninfluenced by the function; addition of information produced by the function would alter the system, possibly in a radical way which would produce changes unknown to the function model thus decreasing prediction accuracy. Consider the ideal transfer function which can predict a system’s future states with 100% accuracy. 
				</p>
				<div class="eqn">
					$$ X_{k+1} = \Phi_{s}(X_k) $$
					$$ X_{k+1} = X_k + \Phi_s'(X_k) $$
				
				</div>
				<p>
					\(s\) denotes natural, uninfluenced by the observer. This function can reliably predict a system’s future states from its current and past states. The instant that information from this function were used to change the system, the system’s state would be modelled by the combination of the original predicted state, and the product of the predicted state and some unknown influence factor \(H\).
				</p>
				<div class="eqn">
					$$ \Phi_N(X_k) = (H + 1) \cdot \Phi_s(X_k) $$				
				</div>
				<p>
					This action would change the system such that Φ_♮ would no longer be an accurate reflection of the system’s state. A new function which includes observer influence, denoted by \(N\), would become the ideal model. As the observer makes changes in the system, there would continue to be influence from the original function. System states at this stage are modelled as a combination of the new function and the natural. 
				</p>
				
				<div class="eqn">
					$$ \Phi_N(X_k) = H \cdot \Phi_N(X_k) + \Phi_s(X_k) $$
				</div>
				
				<p>
					As the observer continues to make changes in the system, natural processes will become user influenced processes. If enough actions are made by the observer, the system change unaccounted for by the \(N)\ function would approach zero. Eventually, future system states can be modelled as a function of influenced states, influence factor and a random term represented by gamma.
				</p>
			
				<div class="eqn">
					$$ X_{k+1} = H \cdot f'(f'(X_{k-1})) + \gamma_k $$
				</div>
				
				<p>
					This resembles the general form of a Kalman filter, and it might be useful to explore these similarities. A network might train on data it creates, progressively becoming more accurate, or it might be that this random term is insurmountable, and there is no way to simultaneously make changes to a chaotic system and maintain prediction accuracy. Some other time perhaps.
				</p>
			
			
			
			</div>

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<div id="appendix">
				<h2>Appendix</h2>
				<p>
					The original report is available from the provided link. It contains all images, tables, and appendicies referenced in the text. 
				</p>		
			</div>
		</div>
	</body>
</html>